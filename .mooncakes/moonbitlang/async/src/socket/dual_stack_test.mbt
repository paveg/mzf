// Copyright 2025 International Digital Economy Academy
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

///|
let all_protocol_preferences : FixedArray[@socket.IpProtocolPreference] = [
  @socket.FavorV4,
  @socket.OnlyV4,
  @socket.FavorV6,
  @socket.OnlyV6,
]

///|
async test "Only_V4 server" {
  let log = StringBuilder::new()
  @async.with_task_group(fn(root) {
    let server = @socket.TcpServer::new(@socket.Addr::parse("0.0.0.0:0"))
    let port = server.addr().port()
    root.spawn_bg(no_wait=true, fn() {
      server.run_forever((conn, addr) => {
        let addr_str = addr.to_string()
        guard addr_str.rev_find(":") is Some(ip_end)
        let ip = addr_str[:ip_end]
        let msg = conn.read_all().text()
        log.write_string("server received \{repr(msg)} from \{ip}\n")
      })
    })
    async fn client(protocol) {
      let conn = @socket.Tcp::connect_to_host("localhost", port~, protocol~) catch {
        @os_error.OSError(_) as err if err.is_ECONNREFUSED() =>
          raise Failure::Failure("connection refused")
        err => raise err
      }
      defer conn.close()
      conn.write("message")
    }

    for protocol in all_protocol_preferences {
      let result = try? client(protocol)
      @async.sleep(100)
      log.write_string("client(\{protocol}): \{result}\n")
    }
    // give some time for the server to process the last connection
    @async.sleep(300)
  })
  inspect(
    log.to_string(),
    content=(
      #|server received "message" from 127.0.0.1
      #|client(FavorV4): Ok(())
      #|server received "message" from 127.0.0.1
      #|client(OnlyV4): Ok(())
      #|server received "message" from 127.0.0.1
      #|client(FavorV6): Ok(())
      #|client(OnlyV6): Err(Failure("connection refused"))
      #|
    ),
  )
}

///|
async test "Only_V6 server" {
  let log = StringBuilder::new()
  @async.with_task_group(fn(root) {
    let server = @socket.TcpServer::new(
      @socket.Addr::parse("[::]:0"),
      dual_stack=false,
    )
    let port = server.addr().port()
    root.spawn_bg(no_wait=true, fn() {
      server.run_forever((conn, addr) => {
        let addr_str = addr.to_string()
        guard addr_str.rev_find(":") is Some(ip_end)
        let ip = addr_str[:ip_end]
        let msg = conn.read_all().text()
        log.write_string("server received \{repr(msg)} from \{ip}\n")
      })
    })
    async fn client(protocol) {
      let conn = @socket.Tcp::connect_to_host("localhost", port~, protocol~) catch {
        @os_error.OSError(_) as err if err.is_ECONNREFUSED() =>
          raise Failure::Failure("connection refused")
        err => raise err
      }
      defer conn.close()
      conn.write("message")
    }

    for protocol in all_protocol_preferences {
      let result = try? client(protocol)
      @async.sleep(100)
      log.write_string("client(\{protocol}): \{result}\n")
    }
    // give some time for the server to process the last connection
    @async.sleep(300)
  })
  inspect(
    log.to_string(),
    content=(
      #|server received "message" from [::1]
      #|client(FavorV4): Ok(())
      #|client(OnlyV4): Err(Failure("connection refused"))
      #|server received "message" from [::1]
      #|client(FavorV6): Ok(())
      #|server received "message" from [::1]
      #|client(OnlyV6): Ok(())
      #|
    ),
  )
}

///|
async test "dual stack server" {
  let log = StringBuilder::new()
  @async.with_task_group(fn(root) {
    let server = @socket.TcpServer::new(@socket.Addr::parse("[::]:0"))
    let port = server.addr().port()
    root.spawn_bg(no_wait=true, fn() {
      server.run_forever((conn, addr) => {
        let addr_str = addr.to_string()
        guard addr_str.rev_find(":") is Some(ip_end)
        let ip = addr_str[:ip_end]
        let msg = conn.read_all().text()
        log.write_string("server received \{repr(msg)} from \{ip}\n")
      })
    })
    async fn client(protocol) {
      let conn = @socket.Tcp::connect_to_host("localhost", port~, protocol~)
      defer conn.close()
      conn.write("message")
    }

    for protocol in all_protocol_preferences {
      let result = try? client(protocol)
      @async.sleep(100)
      log.write_string("client(\{protocol}): \{result}\n")
    }
    // give some time for the server to process the last connection
    @async.sleep(300)
  })
  inspect(
    log.to_string(),
    content=(
      #|server received "message" from [::ffff:127.0.0.1]
      #|client(FavorV4): Ok(())
      #|server received "message" from [::ffff:127.0.0.1]
      #|client(OnlyV4): Ok(())
      #|server received "message" from [::1]
      #|client(FavorV6): Ok(())
      #|server received "message" from [::1]
      #|client(OnlyV6): Ok(())
      #|
    ),
  )
}

///|
async test "Only_V4 UDP server" {
  let log = StringBuilder::new()
  @async.with_task_group(fn(root) {
    let server = @socket.UdpServer::new(@socket.Addr::parse("0.0.0.0:0"))
    let port = server.addr().port()
    root.spawn_bg(no_wait=true, fn() {
      defer server.close()
      let buf = FixedArray::make(1024, b'\x00')
      for {
        let (len, addr) = server.recvfrom(buf)
        let msg = @encoding/utf8.decode(buf.unsafe_reinterpret_as_bytes()[:len])
        let addr_str = addr.to_string()
        guard addr_str.rev_find(":") is Some(ip_end)
        let ip = addr_str[:ip_end]
        log.write_string("server received \{repr(msg)} from \{ip}\n")
      }
    })
    async fn client(protocol) {
      let addr = @socket.Addr::resolve("localhost", port~, protocol~)
      let client = @socket.UdpClient::new(addr)
      defer client.close()
      client.send("message")
    }

    for protocol in all_protocol_preferences {
      let result = try? client(protocol)
      @async.sleep(100)
      log.write_string("client(\{protocol}): \{result}\n")
    }
    // give some time for the server to process the last connection
    @async.sleep(300)
  })
  inspect(
    log.to_string(),
    content=(
      #|server received "message" from 127.0.0.1
      #|client(FavorV4): Ok(())
      #|server received "message" from 127.0.0.1
      #|client(OnlyV4): Ok(())
      #|client(FavorV6): Ok(())
      #|client(OnlyV6): Ok(())
      #|
    ),
  )
}

///|
async test "Only_V6 UDP server" {
  let log = StringBuilder::new()
  @async.with_task_group(fn(root) {
    let server = @socket.UdpServer::new(
      @socket.Addr::parse("[::]:0"),
      dual_stack=false,
    )
    let port = server.addr().port()
    root.spawn_bg(no_wait=true, fn() {
      defer server.close()
      let buf = FixedArray::make(1024, b'\x00')
      for {
        let (len, addr) = server.recvfrom(buf)
        let msg = @encoding/utf8.decode(buf.unsafe_reinterpret_as_bytes()[:len])
        let addr_str = addr.to_string()
        guard addr_str.rev_find(":") is Some(ip_end)
        let ip = addr_str[:ip_end]
        log.write_string("server received \{repr(msg)} from \{ip}\n")
      }
    })
    async fn client(protocol) {
      let addr = @socket.Addr::resolve("localhost", port~, protocol~)
      let client = @socket.UdpClient::new(addr)
      defer client.close()
      client.send("message")
    }

    for protocol in all_protocol_preferences {
      let result = try? client(protocol)
      @async.sleep(100)
      log.write_string("client(\{protocol}): \{result}\n")
    }
    // give some time for the server to process the last connection
    @async.sleep(300)
  })
  inspect(
    log.to_string(),
    content=(
      #|client(FavorV4): Ok(())
      #|client(OnlyV4): Ok(())
      #|server received "message" from [::1]
      #|client(FavorV6): Ok(())
      #|server received "message" from [::1]
      #|client(OnlyV6): Ok(())
      #|
    ),
  )
}

///|
async test "dual stack UDP server" {
  let log = StringBuilder::new()
  @async.with_task_group(fn(root) {
    let server = @socket.UdpServer::new(@socket.Addr::parse("[::]:0"))
    let port = server.addr().port()
    root.spawn_bg(no_wait=true, fn() {
      defer server.close()
      let buf = FixedArray::make(1024, b'\x00')
      for {
        let (len, addr) = server.recvfrom(buf)
        let msg = @encoding/utf8.decode(buf.unsafe_reinterpret_as_bytes()[:len])
        let addr_str = addr.to_string()
        guard addr_str.rev_find(":") is Some(ip_end)
        let ip = addr_str[:ip_end]
        log.write_string("server received \{repr(msg)} from \{ip}\n")
      }
    })
    async fn client(protocol) {
      let addr = @socket.Addr::resolve("localhost", port~, protocol~)
      let client = @socket.UdpClient::new(addr)
      defer client.close()
      client.send("message")
    }

    for protocol in all_protocol_preferences {
      let result = try? client(protocol)
      @async.sleep(100)
      log.write_string("client(\{protocol}): \{result}\n")
    }
    // give some time for the server to process the last connection
    @async.sleep(300)
  })
  inspect(
    log.to_string(),
    content=(
      #|server received "message" from [::ffff:127.0.0.1]
      #|client(FavorV4): Ok(())
      #|server received "message" from [::ffff:127.0.0.1]
      #|client(OnlyV4): Ok(())
      #|server received "message" from [::1]
      #|client(FavorV6): Ok(())
      #|server received "message" from [::1]
      #|client(OnlyV6): Ok(())
      #|
    ),
  )
}
