// Generated using `moon info`, DON'T EDIT IT
package "moonbitlang/async/websocket"

import(
  "moonbitlang/async/http"
  "moonbitlang/async/io"
)

// Values

// Errors
pub suberror WebSocketError {
  ConnectionClosed(CloseCode, String?)
  InvalidHandshake(String)
  ProtocolError(String)
}
pub impl Show for WebSocketError

// Types and methods
pub(all) enum CloseCode {
  Normal
  GoingAway
  ProtocolError
  UnsupportedData
  Abnormal
  InvalidFramePayload
  PolicyViolation
  MessageTooBig
  MissingExtension
  InternalError
  Other(UInt16)
}
pub impl Eq for CloseCode
pub impl Show for CloseCode

type Conn
pub fn Conn::close(Self) -> Unit
#as_free_fn
pub async fn Conn::connect(String, headers? : Map[String, String], proxy? : @http.Client) -> Self
pub async fn Conn::end_message(Self) -> Unit
#as_free_fn
pub async fn Conn::from_http_client(@http.Client, String, extra_headers? : Map[String, String]) -> Self
#as_free_fn
pub async fn Conn::from_http_server(@http.Request, @http.ServerConnection) -> Self
pub async fn Conn::ping(Self, msg? : BytesView) -> Unit
pub async fn Conn::recv(Self) -> Message
pub async fn Conn::send_binary(Self, BytesView) -> Unit
pub async fn Conn::send_close(Self, code? : CloseCode, reason? : String) -> Unit
pub async fn Conn::send_text(Self, StringView) -> Unit
pub fn Conn::start_message(Self, MessageKind) -> Unit
pub impl @io.Writer for Conn

pub struct Message {
  kind : MessageKind
  // private fields
}
pub impl @io.Reader for Message

pub(all) enum MessageKind {
  Binary
  Text
}
pub impl Show for MessageKind

// Type aliases

// Traits

