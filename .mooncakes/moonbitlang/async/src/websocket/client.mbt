// Copyright 2025 International Digital Economy Academy
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

///|
/// Create a WebSocket tunnel from an existing HTTP client.
/// The HTTP client must be in a clean state (i.e. not in the middle of a request).
/// A WebSocket handshake will be sent to `path` via the HTTP client.
/// If the handshake succeeds, a WebSocket tunnel will be established and returned.
///
/// The ownership of the HTTP client will be transferred to this function.
/// So caller must not use the client anymore, nor close it.
///
/// Extra headers during the WebSocket handshake can be specified via `extra_headers`.
/// Some headers are reserved for the WebSocket protocol
/// and must NOT be set in `extra_headers`:
///
/// - those headers set by `@http.Client`, see `@http.Client::new`
/// - `Connection`, `Upgrade`
/// - `Sec-WebSocket-Key`, `Sec-WebSocket,Version`
#as_free_fn
pub async fn Conn::from_http_client(
  conn : @http.Client,
  path : String,
  extra_headers? : Map[String, String] = {},
) -> Conn {
  // Ref : https://datatracker.ietf.org/doc/html/rfc6455#section-4.1
  let seed = @tls.rand_bytes(32)
  let rand = @random.Rand::chacha8(seed~)

  // Send WebSocket handshake request
  let nonce = FixedArray::make(16, b'\x00')
  nonce.unsafe_write_uint32_le(0, rand.uint())
  nonce.unsafe_write_uint32_le(4, rand.uint())
  nonce.unsafe_write_uint32_le(8, rand.uint())
  nonce.unsafe_write_uint32_le(12, rand.uint())
  let key = base64_encode(nonce.unsafe_reinterpret_as_bytes())
  extra_headers["Connection"] = "Upgrade"
  extra_headers["Upgrade"] = "websocket"
  extra_headers["Sec-WebSocket-Key"] = key
  extra_headers["Sec-WebSocket-Version"] = "13"
  try {
    let response = conn..request(Get, path, extra_headers~).end_request()
    guard response.code is 101 else {
      raise InvalidHandshake(
        "Server did not respond with 101 Switching Protocols: \{response.code} \{response.reason}",
      )
    }

    // Validate WebSocket handshake headers
    guard response.headers.get("upgrade") is Some(upgrade) &&
      upgrade.to_lower() == "websocket" else {
      raise InvalidHandshake("Missing or invalid Upgrade header")
    }
    guard response.headers.get("connection") is Some(connection) &&
      connection.to_lower().contains("upgrade") else {
      raise InvalidHandshake("Missing or invalid Connection header")
    }
    guard response.headers.get("sec-websocket-accept") is Some(accept_key) else {
      raise InvalidHandshake("Missing Sec-WebSocket-Accept header")
    }
    let expected_accept_key = generate_accept_key(key)
    guard accept_key == expected_accept_key else {
      raise InvalidHandshake(
        "Invalid Sec-WebSocket-Accept value: \{accept_key} != \{expected_accept_key}",
      )
    }
    conn.enter_passthrough_mode()
    Conn::new(conn, 4096, mask=Some(rand))
  } catch {
    err => {
      conn.close()
      raise err
    }
  }
}

///|
/// Connect to a WebSocket server via the given URL.
/// The protocol of the URL must be either `ws` (for unencrypted WebSocket connection)
/// or `wss` (for TLS encrypted WebSocket connection).
///
/// Extra headers during the WebSocket handshake can be specified via `extra_headers`.
/// Some headers are reserved for the WebSocket protocol
/// and must NOT be set in `extra_headers`:
///
/// - those headers set by `@http.Client`, see `@http.Client::new`
/// - `Connection`, `Upgrade`
/// - `Sec-WebSocket-Key`, `Sec-WebSocket,Version`
///
/// If `proxy` is present, the websocket client will tunnel traffic through the proxy.
/// See `@http.Client::new` for more details.
///
/// Example:
/// ```moonbit no-check
/// let ws = Client::connect("ws://example.com/endpoint")
/// ```
#as_free_fn
pub async fn Conn::connect(
  url : String,
  headers? : Map[String, String] = {},
  proxy? : @http.Client,
) -> Conn {
  guard url.find("://") is Some(protocol_len) else {
    abort("`@websocket.Client::connect()`: invalid URL: missing protocol")
  }
  let http_protocol = match url[:protocol_len] {
    "ws" => "http"
    "wss" => "https"
    protocol =>
      abort("`@websocket.Client::connect()`: invalid protocol \{protocol}")
  }
  let url = url[protocol_len + 3:]
  let (host, path) = if url.find("/") is Some(i) {
    (url[:i].to_string(), url[i:].to_string())
  } else {
    (url.to_string(), "/")
  }
  let path = if path == "" { "/" } else { path }
  let conn = @http.Client::new("\{http_protocol}://\{host}", proxy?)
  Conn::from_http_client(conn, path, extra_headers=headers)
}
