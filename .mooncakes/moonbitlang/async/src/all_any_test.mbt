// Copyright 2025 International Digital Economy Academy
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

///|
async test "all basic" {
  let start = @async.now()
  let results = @async.all([
    fn() {
      @async.sleep(400)
      1
    },
    fn() {
      @async.sleep(200)
      2
    },
    fn() { 3 },
  ])
  let duration = (@async.now() - start).to_int()
  @json.inspect(results, content=[1, 2, 3])
  inspect((duration + 50) / 200, content="2")
}

///|
async test "all preserves order" {
  let log = []
  let results = @async.all([
    fn() {
      @async.sleep(300)
      log.push("task 0")
      0
    },
    fn() {
      @async.sleep(100)
      log.push("task 1")
      1
    },
    fn() {
      log.push("task 2")
      2
    },
  ])
  @json.inspect(log, content=["task 2", "task 1", "task 0"])
  @json.inspect(results, content=[0, 1, 2])
}

///|
async test "all with max_concurrent" {
  let log = []
  let result = @async.all(
    [
      fn() {
        log.push("task #1 started")
        defer log.push("task #1 completed")
        @async.sleep(200)
        0
      },
      fn() {
        log.push("task #2 started")
        defer log.push("task #2 completed")
        @async.sleep(100)
        1
      },
      fn() {
        log.push("task #3 started")
        defer log.push("task #3 completed")
        @async.sleep(200)
        2
      },
    ],
    max_concurrent=2,
  )
  @json.inspect(result, content=[0, 1, 2])
  @json.inspect(log, content=[
    "task #1 started", "task #2 started", "task #2 completed", "task #3 started",
    "task #1 completed", "task #3 completed",
  ])
}

///|
async test "all empty" {
  let results : Array[Int] = @async.all([])
  @json.inspect(results, content=[])
}

///|
async test "all single task" {
  let result = @async.all([fn() { 42 }])
  @json.inspect(result, content=[42])
}

///|
async test "all failure propagates" {
  let log = []
  let result = try? @async.all([
    fn() {
      @async.sleep(100)
      log.push("task #1 completed")
    },
    fn() {
      @async.sleep(200)
      log.push("task #2 failing")
      raise Failure::Failure("Err")
    },
    fn() {
      @async.sleep(300) catch {
        err => {
          log.push("task #3 cancelled with \{err}")
          raise err
        }
      }
      log.push("task #3 completed")
    },
  ])
  @json.inspect(result, content={ "Err": ["Failure", "Err"] })
  @json.inspect(log, content=[
    "task #1 completed", "task #2 failing", "task #3 cancelled with Cancelled",
  ])
}

///|
async test "all cancelled" {
  let log = []
  async fn task(idx : Int, sleep_time : Int) -> Int {
    @async.sleep(sleep_time) catch {
      err => {
        log.push("task #\{idx} cancelled with \{err}")
        raise err
      }
    }
    log.push("task #\{idx} completed")
    idx
  }

  let result = @async.with_timeout_opt(300, () => @async.all([
    () => task(1, 450),
    () => task(2, 150),
  ]))
  inspect(result, content="None")
  @json.inspect(log, content=[
    "task #2 completed", "task #1 cancelled with Cancelled",
  ])
}

///|
async test "any basic" {
  let start = @async.now()
  let result = @async.any([
    fn() {
      @async.sleep(600)
      1
    },
    fn() {
      @async.sleep(200)
      2
    },
    fn() {
      @async.sleep(400)
      3
    },
  ])
  let duration = (@async.now() - start).to_int()
  @json.inspect(result, content=2)
  inspect((duration + 50) / 200, content="1")
}

///|
async test "any returns first success" {
  let log = []
  async fn task(idx : Int, sleep_time : Int) -> Int {
    @async.sleep(sleep_time) catch {
      err => {
        log.push("task #\{idx} cancelled with \{err}")
        raise err
      }
    }
    log.push("task #\{idx} completed")
    idx
  }

  let result = @async.any([
    () => task(1, 600),
    () => task(2, 200),
    () => task(3, 400),
  ])
  @json.inspect(result, content=2)
  @json.inspect(log, content=[
    "task #2 completed", "task #1 cancelled with Cancelled", "task #3 cancelled with Cancelled",
  ])
}

///|
async test "any failure without allow_failure" {
  let log = []
  let result = try? @async.any([
    fn() {
      @async.sleep(300) catch {
        err => {
          log.push("task #1 cancelled with \{err}")
          raise err
        }
      }
      log.push("task #1 completed")
    },
    fn() {
      @async.sleep(150)
      raise Failure::Failure("Err")
    },
  ])
  @json.inspect(result, content={ "Err": ["Failure", "Err"] })
  @json.inspect(log, content=["task #1 cancelled with Cancelled"])
}

///|
async test "any with allow_failure" {
  let log = []
  let result = @async.any(
    [
      fn() {
        @async.sleep(300)
        log.push("task #1 failing")
        raise Err
      },
      fn() {
        @async.sleep(150)
        log.push("task #2 failing")
        raise Failure::Failure("fail")
      },
      fn() {
        @async.sleep(450)
        log.push("task #3 completed")
        2
      },
    ],
    allow_failure=true,
  )
  @json.inspect(log, content=[
    "task #2 failing", "task #1 failing", "task #3 completed",
  ])
  @json.inspect(result, content=2)
}

///|
async test "any with allow_failure all fail" {
  let log = []
  let result = try? @async.any(
    [
      fn() -> Int {
        @async.sleep(300)
        log.push("task #1 failing")
        raise Err
      },
      fn() {
        @async.sleep(150)
        log.push("task #2 failing")
        raise Failure::Failure("fail")
      },
    ],
    allow_failure=true,
  )
  @json.inspect(log, content=["task #2 failing", "task #1 failing"])
  inspect(result, content="Err(Err)")
}

///|
async test "any single task" {
  let result = @async.any([fn() { 42 }])
  @json.inspect(result, content=42)
}

///|
async test "any empty fails" {
  @json.inspect(try? (@async.any([]) : Unit), content={
    "Err": [
      "Failure", "all_any_test.mbt:283:23-283:37@moonbitlang/async_blackbox_test FAILED: no tasks provided to any()",
    ],
  })
}

///|
async test "any cancelled" {
  let log = []
  async fn task(idx : Int, sleep_time : Int) -> Int {
    @async.sleep(sleep_time) catch {
      err => {
        log.push("task #\{idx} cancelled with \{err}")
        raise err
      }
    }
    log.push("task #\{idx} completed")
    idx
  }

  let result = @async.with_timeout_opt(200, () => @async.any([
    () => task(1, 400),
    () => task(2, 400),
  ]))
  inspect(result, content="None")
  @json.inspect(log, content=[
    "task #1 cancelled with Cancelled", "task #2 cancelled with Cancelled",
  ])
}
