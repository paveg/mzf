// Generated using `moon info`, DON'T EDIT IT
package "mizchi/tui/components"

import {
  "mizchi/crater/types",
  "mizchi/signals",
  "mizchi/tui/core",
  "mizchi/tui/events",
  "mizchi/tui/render",
}

// Values
pub fn accordion(Array[AccordionItem], id? : String, focused_id? : String, theme? : Theme, expanded_icon? : String, collapsed_icon? : String, content_padding? : Double, gap? : Double) -> @core.Component

pub fn accordion_header(String, Bool, id? : String, focused? : Bool, theme? : Theme, expanded_icon? : String, collapsed_icon? : String, padding_x? : Double, padding_y? : Double, on_click? : (() -> Unit)?) -> @core.Component

pub fn alert_dialog(String, title? : String, button_label? : String, bg? : @core.Color, border_color? : @core.Color) -> @core.Component

pub fn align_center() -> @types.Alignment

pub fn align_end() -> @types.Alignment

pub fn align_space_around() -> @types.Alignment

pub fn align_space_between() -> @types.Alignment

pub fn align_space_evenly() -> @types.Alignment

pub fn align_start() -> @types.Alignment

pub fn align_stretch() -> @types.Alignment

pub fn align_text(String, Int, align? : TextAlign) -> String

pub fn ansi_move_to(Int, Int) -> String

pub fn ansi_restore_cursor() -> String

pub fn ansi_save_cursor() -> String

pub fn[T] apply_scroll(Array[T], Int, Int, reserve_indicator? : Bool) -> Array[T]

pub fn autocomplete(Array[ComboboxOption], String, id? : String, focused_id? : String, placeholder? : String, theme? : Theme, min_width? : Double, max_visible? : Int) -> @core.Component

pub fn backdrop(bg? : @core.Color) -> @core.Component

pub fn bold(String) -> @core.Component

pub fn bordered(Array[@core.Component], style? : @core.BorderChars, color? : @core.Color) -> @core.Component

pub fn build_progress_bar(Double, Int, style? : ProgressStyle, show_percent? : Bool) -> String

pub fn build_scrollbar(Int, Int, Int, Int, track_char? : String, thumb_char? : String) -> Array[String]

pub fn button(String, id? : String, state? : ButtonState, theme? : Theme, min_width? : Double, padding_x? : Double, padding_y? : Double, on_click? : (() -> Unit)?) -> @core.Component

pub fn calc_labeled_block_lines(String, Int, String) -> Int

pub fn calc_max_scroll(Int, Int, reserve_indicator? : Bool) -> Int

pub fn calc_split_sizes(Int, SplitSize, SplitSize, divider_size? : Int) -> (Int, Int)

pub fn calc_text_lines(String, Int) -> Int

pub fn card(Array[@core.Component], id? : String, border_color? : @core.Color, bg? : @core.Color, padding? : Double) -> @core.Component

pub fn center(Array[@core.Component]) -> @core.Component

pub fn checkbox(Bool, id? : String, focused? : Bool, disabled? : Bool, theme? : Theme, checked_icon? : String, unchecked_icon? : String, on_click? : (() -> Unit)?) -> @core.Component

pub fn colored(String, @core.Color) -> @core.Component

pub fn column(Array[@core.Component], id? : String, width? : @types.Dimension, height? : @types.Dimension, min_width? : @types.Dimension, min_height? : @types.Dimension, max_width? : @types.Dimension, max_height? : @types.Dimension, flex_grow? : Double, flex_shrink? : Double, flex_basis? : @types.Dimension, justify? : @types.Alignment, align? : @types.Alignment, wrap? : Bool, gap? : Double, padding? : Double, padding_x? : Double, padding_y? : Double, margin? : Double, margin_x? : Double, margin_y? : Double, border? : @core.BorderChars?, border_color? : @core.Color, bg? : @core.Color, fg? : @core.Color, on_click? : (() -> Unit)?, role? : @core.Role?) -> @core.Component

pub fn combobox(Array[ComboboxOption], String, id? : String, focused_id? : String, state? : ComboboxState, filter? : String, placeholder? : String, theme? : Theme, width? : @types.Dimension, min_width? : Double, max_visible? : Int, dropdown_icon? : String, dropdown_icon_open? : String) -> @core.Component

pub fn confirm_dialog(String, title? : String, confirm_label? : String, cancel_label? : String, bg? : @core.Color, border_color? : @core.Color) -> @core.Component

pub fn context_menu(Array[MenuItem], focused_id? : String, id? : String, theme? : Theme, min_width? : Double) -> @core.Component

pub fn count_lines(String) -> Int

pub fn dim_auto() -> @types.Dimension

pub fn dim_length(Double) -> @types.Dimension

pub fn dim_percent(Double) -> @types.Dimension

pub fn editor(EditorState, @core.Color, @core.Color, @core.Color, @core.Color, @core.Color, Double, Double, Bool, String) -> @core.Component

pub fn fill(Array[@core.Component]) -> @core.Component

pub fn footer(Array[@core.Component], fg? : @core.Color) -> @core.Component

pub fn form_edit_config(String, @signals.Signal[String], on_edit_start? : (() -> Unit)?, on_edit_end? : (() -> Unit)?, on_force_quit? : (() -> Unit)?) -> EditConfig

pub fn fraction_text(Int, Int, theme? : Theme) -> @core.Component

pub fn fullscreen(Array[@core.Component], Int, Int, border? : @core.BorderChars?, border_color? : @core.Color, padding? : Double) -> @core.Component

pub fn get_spinner_frame(Int) -> String

pub fn grid(Array[@core.Component], columns? : Int, column_gap? : Double, row_gap? : Double, width? : @types.Dimension, height? : @types.Dimension, min_width? : @types.Dimension, min_height? : @types.Dimension, max_width? : @types.Dimension, max_height? : @types.Dimension, justify_items? : @types.Alignment, align_items? : @types.Alignment, padding? : Double, padding_x? : Double, padding_y? : Double, margin? : Double, margin_x? : Double, margin_y? : Double, border? : @core.BorderChars?, border_color? : @core.Color, bg? : @core.Color, fg? : @core.Color) -> @core.Component

pub fn hdivider(char? : Char, fg? : @core.Color, width? : Int) -> @core.Component

pub fn hspace(Double) -> @core.Component

pub fn hsplit(Array[@core.Component], Array[@core.Component], Int, SplitSize, SplitSize, divider? : @core.Component?, divider_size? : Int) -> @core.Component

pub fn hsplit_fixed_bottom(Array[@core.Component], Array[@core.Component], Int, Int, divider? : @core.Component?) -> @core.Component

pub fn hsplit_fixed_top(Array[@core.Component], Array[@core.Component], Int, Int, divider? : @core.Component?) -> @core.Component

pub fn icon_button(String, state? : ButtonState, theme? : Theme) -> @core.Component

pub fn ime_input(String, Bool, focused? : Bool, disabled? : Bool, id? : String, placeholder? : String, fg? : @core.Color, bg? : @core.Color, placeholder_fg? : @core.Color, focus_border_color? : @core.Color, edit_border_color? : @core.Color, disabled_fg? : @core.Color, disabled_bg? : @core.Color, width? : @types.Dimension, height? : @types.Dimension, min_width? : Double, min_height? : Double, padding_x? : Double, padding_y? : Double) -> @core.Component

pub fn ime_textarea(String, Bool, focused? : Bool, disabled? : Bool, id? : String, rows? : Int, placeholder? : String, fg? : @core.Color, bg? : @core.Color, placeholder_fg? : @core.Color, focus_border_color? : @core.Color, edit_border_color? : @core.Color, disabled_fg? : @core.Color, disabled_bg? : @core.Color, width? : @types.Dimension, min_width? : Double, padding_x? : Double, padding_y? : Double) -> @core.Component

pub fn input(String, id? : String, placeholder? : String, state? : InputState, fg? : @core.Color, bg? : @core.Color, placeholder_fg? : @core.Color, focus_border_color? : @core.Color, edit_border_color? : @core.Color, disabled_fg? : @core.Color, disabled_bg? : @core.Color, width? : @types.Dimension, height? : @types.Dimension, min_width? : Double, min_height? : Double, padding_x? : Double, padding_y? : Double) -> @core.Component

pub fn input_plain(String, placeholder? : String, state? : InputState, fg? : @core.Color, bg? : @core.Color, placeholder_fg? : @core.Color, underline? : Bool) -> @core.Component

pub fn labeled_block(String, String, String, label_color? : @core.Color, content_color? : @core.Color, bold_label? : Bool, width? : Int, height? : Int, indent? : String) -> @core.Component

pub fn labeled_block_assistant_color() -> @core.Color

pub fn labeled_block_error_color() -> @core.Color

pub fn labeled_block_pending_color() -> @core.Color

pub fn labeled_block_success_color() -> @core.Color

pub fn labeled_block_user_color() -> @core.Color

pub fn labeled_checkbox(String, Bool, id? : String, focused? : Bool, disabled? : Bool, label_position? : LabelPosition, theme? : Theme, gap? : Double, on_click? : (() -> Unit)?) -> @core.Component

pub fn labeled_switch(String, Bool, id? : String, focused? : Bool, disabled? : Bool, label_position? : LabelPosition, theme? : Theme, gap? : Double, on_click? : (() -> Unit)?) -> @core.Component

pub fn listbox(Array[ListboxOption], String, id? : String, focused_id? : String, orientation? : ListboxOrientation, theme? : Theme, min_width? : Double, max_height? : Int, padding_x? : Double) -> @core.Component

pub fn listbox_multi(Array[ListboxOption], ListboxState, id? : String, orientation? : ListboxOrientation, theme? : Theme, min_width? : Double, max_height? : Int, padding_x? : Double) -> @core.Component

pub fn listbox_option(String, String, disabled? : Bool) -> ListboxOption

pub fn loading_dots(Int, label? : String, theme? : Theme) -> @core.Component

pub fn menu(Array[MenuItem], focused_id? : String, id? : String, theme? : Theme, min_width? : Double) -> @core.Component

pub fn menu_checkbox(String, String, Bool, disabled? : Bool) -> MenuItem

pub fn menu_item(String, String, disabled? : Bool) -> MenuItem

pub fn menu_radio(String, String, Bool, disabled? : Bool) -> MenuItem

pub fn menu_separator() -> MenuItem

pub fn menu_submenu(String, String, Array[MenuItem], disabled? : Bool) -> MenuItem

pub fn menubar(Array[MenubarItem], MenubarState, id? : String, theme? : Theme, item_padding_x? : Double, dropdown_min_width? : Double) -> @core.Component

pub fn modal(@core.Component, id? : String, width? : @types.Dimension, height? : @types.Dimension, min_width? : @types.Dimension, min_height? : @types.Dimension, max_width? : @types.Dimension, max_height? : @types.Dimension, bg? : @core.Color, fg? : @core.Color, border? : @core.BorderChars?, border_color? : @core.Color, padding? : Double, padding_x? : Double, padding_y? : Double) -> @core.Component

pub fn modal_with_backdrop(@core.Component, id? : String, width? : @types.Dimension, height? : @types.Dimension, min_width? : @types.Dimension, min_height? : @types.Dimension, max_width? : @types.Dimension, max_height? : @types.Dimension, bg? : @core.Color, fg? : @core.Color, border? : @core.BorderChars?, border_color? : @core.Color, padding? : Double, padding_x? : Double, padding_y? : Double, backdrop_bg? : @core.Color, container_width? : @types.Dimension, container_height? : @types.Dimension) -> @core.Component

pub fn multiline_input(String, id? : String, rows? : Int, placeholder? : String, state? : TextareaState, fg? : @core.Color, bg? : @core.Color, placeholder_fg? : @core.Color, focus_border_color? : @core.Color, edit_border_color? : @core.Color, disabled_fg? : @core.Color, disabled_bg? : @core.Color, width? : @types.Dimension, min_width? : Double, padding_x? : Double, padding_y? : Double) -> @core.Component

pub fn option_list(Array[ListboxOption], Array[String], focused_id? : String, multiselectable? : Bool, theme? : Theme) -> @core.Component

pub fn padded(Array[@core.Component], padding? : Double) -> @core.Component

pub fn panel(Array[@core.Component], id? : String, border_color? : @core.Color, bg? : @core.Color) -> @core.Component

pub fn percent_text(Double, theme? : Theme) -> @core.Component

pub fn progress_bar(Double, Int, style? : ProgressStyle, show_percent? : Bool, theme? : Theme) -> @core.Component

pub fn radio(String, Bool, id? : String, focused? : Bool, theme? : Theme, selected_icon? : String, unselected_icon? : String, gap? : Double) -> @core.Component

pub fn radiogroup(Array[RadioOption], String, id? : String, focused_id? : String, orientation? : RadioOrientation, theme? : Theme, selected_icon? : String, unselected_icon? : String, gap? : Double, item_gap? : Double) -> @core.Component

pub fn resizable_pane(@core.Component, @core.Component, Int, orientation? : SplitterOrientation, id? : String, focused? : Bool, show_position? : Bool, total_size? : Int) -> @core.Component

pub fn row(Array[@core.Component], id? : String, width? : @types.Dimension, height? : @types.Dimension, min_width? : @types.Dimension, min_height? : @types.Dimension, max_width? : @types.Dimension, max_height? : @types.Dimension, flex_grow? : Double, flex_shrink? : Double, flex_basis? : @types.Dimension, justify? : @types.Alignment, align? : @types.Alignment, wrap? : Bool, gap? : Double, padding? : Double, padding_x? : Double, padding_y? : Double, margin? : Double, margin_x? : Double, margin_y? : Double, border? : @core.BorderChars?, border_color? : @core.Color, bg? : @core.Color, fg? : @core.Color, on_click? : (() -> Unit)?, role? : @core.Role?) -> @core.Component

pub fn scroll_indicator(ScrollIndicator, fg? : @core.Color) -> @core.Component

pub fn scroll_indicator_text(ScrollIndicator) -> String

pub fn scrollable_list(Array[@core.Component], ScrollState, Int, show_indicator? : Bool, indicator_fg? : @core.Color) -> Array[@core.Component]

pub fn scrollbar(Int, Int, Int, Int, track_color? : @core.Color, thumb_color? : @core.Color, track_char? : String, thumb_char? : String) -> @core.Component

pub fn select(Array[ComboboxOption], String, id? : String, focused_id? : String, open? : Bool, placeholder? : String, theme? : Theme, min_width? : Double, max_visible? : Int) -> @core.Component

pub fn selectable_list(Array[(String, String)], String, focused_id? : String, theme? : Theme) -> @core.Component

pub fn simple_editor(TextBuffer, @core.Color, @core.Color, @core.Color) -> @core.Component

pub fn snapshot(HeadlessApp, String) -> Unit

pub fn spacer(flex_grow? : Double) -> @core.Component

pub fn spinner(Int, label? : String, theme? : Theme) -> @core.Component

pub fn split_lines(String) -> Array[String]

pub fn splitter_handle(SplitterOrientation, focused? : Bool, id? : String, fg? : @core.Color, bg? : @core.Color, focused_fg? : @core.Color, focused_bg? : @core.Color) -> @core.Component

pub fn start_edit(EditConfig, String, () -> Unit, confirm_on_shift_enter? : Bool, esc_cancels? : Bool) -> Unit

pub fn start_edit_inplace(EditConfig, String, Int, Int, Int, Int, Bool, () -> Unit, confirm_on_shift_enter? : Bool, esc_cancels? : Bool, on_lines_change? : ((Int) -> Int)?, on_completion? : ((String, Int) -> String?)?) -> Unit

pub fn start_edit_inplace_in_bounds(EditConfig, String, @events.HitTestResult, Bool, () -> Unit, confirm_on_shift_enter? : Bool, esc_cancels? : Bool, border? : Int, on_lines_change? : ((Int) -> Int)?, on_completion? : ((String, Int) -> String?)?) -> Unit

pub fn streaming_block(String, String, String, is_streaming? : Bool, label_color? : @core.Color, content_color? : @core.Color, bold_label? : Bool, width? : Int, height? : Int, indent? : String, cursor_char? : String) -> @core.Component

pub fn streaming_text(String, is_streaming? : Bool, cursor_char? : String, fg? : @core.Color, width? : Int, height? : Int) -> @core.Component

pub fn switch(Bool, id? : String, focused? : Bool, disabled? : Bool, theme? : Theme, track_on? : String, track_off? : String, on_click? : (() -> Unit)?) -> @core.Component

pub fn tab_container(Array[TabItem], String, @core.Component, id? : String, focused_id? : String, theme? : Theme, padding_x? : Double) -> @core.Component

pub fn tab_panel(@core.Component, id? : String, theme? : Theme, border? : @core.BorderChars?, padding? : Double) -> @core.Component

pub fn tabs(Array[TabItem], String, id? : String, focused_id? : String, theme? : Theme, padding_x? : Double) -> @core.Component

pub fn tabs_boxed(Array[TabItem], String, id? : String, focused_id? : String, theme? : Theme, padding_x? : Double) -> @core.Component

pub fn tabs_underline(Array[TabItem], String, id? : String, focused_id? : String, theme? : Theme, padding_x? : Double) -> @core.Component

pub fn text(String, fg? : @core.Color, bg? : @core.Color, bold? : Bool, underline? : Bool) -> @core.Component

pub fn text_button(String, state? : ButtonState, theme? : Theme, underline? : Bool) -> @core.Component

pub fn textarea(String, id? : String, rows? : Int, placeholder? : String, state? : TextareaState, fg? : @core.Color, bg? : @core.Color, placeholder_fg? : @core.Color, focus_border_color? : @core.Color, edit_border_color? : @core.Color, disabled_fg? : @core.Color, disabled_bg? : @core.Color, width? : @types.Dimension, min_width? : Double, padding_x? : Double, padding_y? : Double) -> @core.Component

pub fn title_bar(String, fg? : @core.Color) -> @core.Component

pub fn truncate_text(String, Int) -> String

pub fn vdivider(char? : Char, fg? : @core.Color) -> @core.Component

pub fn vspace(Double) -> @core.Component

pub fn vsplit(Array[@core.Component], Array[@core.Component], Int, SplitSize, SplitSize, divider? : @core.Component?, divider_size? : Int) -> @core.Component

pub fn vsplit_fixed_left(Array[@core.Component], Array[@core.Component], Int, Int, divider? : @core.Component?) -> @core.Component

pub fn vsplit_fixed_right(Array[@core.Component], Array[@core.Component], Int, Int, divider? : @core.Component?) -> @core.Component

pub fn window_splitter(@core.Component, @core.Component, SplitterState, orientation? : SplitterOrientation, id? : String, min? : Int, max? : Int, divider_fg? : @core.Color, divider_bg? : @core.Color, focused_fg? : @core.Color, focused_bg? : @core.Color, total_size? : Int, divider_width? : Double) -> @core.Component

pub fn with_modal(@core.Component, @core.Component, Bool) -> @core.Component

pub fn wrap_text(String, Int) -> Array[String]

// Errors

// Types and methods
pub(all) struct AccordionItem {
  id : String
  title : String
  content : @core.Component
  expanded : Bool
}

pub(all) struct ActionItem {
  key : Char
  label : String
  handler : () -> Unit
}
pub fn ActionItem::new(Char, String, () -> Unit) -> Self

pub(all) struct ActionMenu {
  modal : ModalState
  title : String
  actions : Array[ActionItem]
  toggle_key : Char?
  on_close : () -> Unit
}
pub fn ActionMenu::build(Self, Int, Int) -> @core.Component
pub fn ActionMenu::close(Self) -> Unit
pub fn ActionMenu::handle_escape(Self) -> Bool
pub fn ActionMenu::handle_event(Self, @render.App, @events.InputEvent) -> MenuKeyResult
pub fn ActionMenu::handle_key(Self, Char) -> Bool
pub fn ActionMenu::is_open(Self) -> Bool
pub fn ActionMenu::new(String, Array[ActionItem], toggle_key? : Char?, on_close? : () -> Unit) -> Self
pub fn ActionMenu::open(Self) -> Unit
pub fn ActionMenu::open_with_app(Self, @render.App) -> Unit

pub(all) enum ButtonState {
  Normal
  Hover
  Pressed
  Focused
  Disabled
}

pub(all) struct ComboboxOption {
  id : String
  label : String
}
pub impl Eq for ComboboxOption

pub(all) enum ComboboxState {
  Closed
  Open
  Editing
  Disabled
}

pub(all) struct CursorPosition {
  row : Int
  col : Int
}
pub fn CursorPosition::new(row? : Int, col? : Int) -> Self

pub(all) struct EditConfig {
  field_name : String
  on_change : (String) -> Unit
  on_edit_start : (() -> Unit)?
  on_edit_end : (() -> Unit)?
  on_force_quit : (() -> Unit)?
}

pub(all) struct EditContext {
  focused_id : @signals.Signal[String]
  configs : Map[String, EditConfig]
  restore_tui : () -> Unit
}
pub fn EditContext::edit(Self, String, String) -> Bool
pub fn EditContext::edit_focused(Self) -> Bool
pub fn EditContext::new(@signals.Signal[String], () -> Unit) -> Self
pub fn EditContext::register(Self, String, EditConfig) -> Unit

pub(all) struct EditorState {
  buffer : TextBuffer
  undo_stack : UndoStack
  filename : String
  mode : SelectionMode
  modified : Bool
}
pub fn EditorState::from_file(String) -> Self
pub fn EditorState::new() -> Self

pub(all) struct FocusNav {
  focused_id : @signals.Signal[String]
  ids : Array[String]
}
pub fn FocusNav::blur(Self) -> Unit
pub fn FocusNav::button_state(Self, String) -> ButtonState
pub fn FocusNav::focused_in(Self, Array[String]) -> Bool
pub fn FocusNav::get(Self) -> String
pub fn FocusNav::handle_arrows(Self, @events.InputEvent) -> Bool
pub fn FocusNav::handle_tab(Self, @events.InputEvent) -> Bool
pub fn FocusNav::input_state(Self, String) -> InputState
pub fn FocusNav::is_focused(Self, String) -> Bool
pub fn FocusNav::new(Array[String]) -> Self
pub fn FocusNav::next(Self) -> Unit
pub fn FocusNav::prev(Self) -> Unit
pub fn FocusNav::set(Self, String) -> Unit
pub fn FocusNav::textarea_state(Self, String) -> TextareaState
pub fn FocusNav::with_initial(Array[String], String) -> Self

pub(all) struct HeadlessApp {
  width : Int
  height : Int
  output : String
}
pub fn HeadlessApp::ansi_output(Self) -> String
pub fn HeadlessApp::content(Self) -> String
pub fn HeadlessApp::locator(Self, String) -> Locator
pub fn HeadlessApp::new(width? : Int, height? : Int) -> Self
pub fn HeadlessApp::render(Self, @core.Component) -> Self

pub(all) struct ImeSession {
  is_editing : @signals.Signal[Bool]
}
pub fn ImeSession::is_editing(Self) -> Bool
pub fn ImeSession::new() -> Self
pub fn ImeSession::start(Self, EditConfig, String, () -> Unit, confirm_on_shift_enter? : Bool, esc_cancels? : Bool) -> Unit

pub(all) enum InputState {
  Idle
  Focused
  Editing
  Disabled
}

pub(all) struct ItemScroller {
  offset : @signals.Signal[Int]
  auto_scroll : @signals.Signal[Bool]
}
pub fn ItemScroller::can_scroll_down(Self, Int, Int) -> Bool
pub fn ItemScroller::can_scroll_up(Self) -> Bool
pub fn ItemScroller::down(Self, Int, Int, Int) -> Bool
pub fn ItemScroller::follow_bottom(Self, Int, Int) -> Unit
pub fn ItemScroller::indicator(Self, Int, Int) -> ScrollIndicator
pub fn ItemScroller::new() -> Self
pub fn[T] ItemScroller::slice(Self, Array[T], Int) -> Array[T]
pub fn ItemScroller::to_bottom(Self, Int, Int) -> Unit
pub fn ItemScroller::up(Self, Int) -> Bool

pub(all) struct Keyboard {
  app : HeadlessApp
}
pub fn Keyboard::press(Self, String) -> Self
pub fn Keyboard::type_text(Self, String) -> Self

pub(all) enum LabelPosition {
  Left
  Right
}

pub(all) struct LineScroller {
  offset : @signals.Signal[Int]
  auto_scroll : @signals.Signal[Bool]
}
pub fn LineScroller::can_scroll_down(Self, Int, Int) -> Bool
pub fn LineScroller::can_scroll_up(Self) -> Bool
pub fn LineScroller::down(Self, Int, Int, Int) -> Bool
pub fn LineScroller::follow_bottom(Self, Int, Int) -> Unit
pub fn LineScroller::new() -> Self
pub fn[T] LineScroller::slice(Self, Array[T], Array[Int], Int) -> Array[T]
pub fn[T] LineScroller::slice_with_offset(Self, Array[T], Array[Int], Int) -> (Array[T], Int)
pub fn LineScroller::to_bottom(Self, Int, Int) -> Unit
pub fn LineScroller::up(Self, Int) -> Bool

pub(all) struct ListboxOption {
  id : String
  label : String
  disabled : Bool
}
pub impl Eq for ListboxOption

pub(all) enum ListboxOrientation {
  Vertical
  Horizontal
}

pub(all) struct ListboxState {
  focused_id : String
  selected_ids : Array[String]
  anchor_id : String
}
pub fn ListboxState::new(initial_selected? : Array[String]) -> Self

pub(all) struct Locator {
  id : String
}

pub(all) struct MenuItem {
  id : String
  label : String
  item_type : MenuItemType
  disabled : Bool
}

pub(all) enum MenuItemType {
  Action
  Checkbox(Bool)
  Radio(Bool)
  Separator
  Submenu(Array[MenuItem])
}

pub(all) enum MenuKeyResult {
  Handled
  NotHandled
  Closed
}

pub(all) struct MenubarItem {
  id : String
  label : String
  items : Array[MenuItem]
}

pub(all) struct MenubarState {
  open_menu_id : String
  focused_item_id : String
  open_submenu_path : Array[String]
}
pub fn MenubarState::new() -> Self

pub(all) struct ModalState {
  is_open : @signals.Signal[Bool]
}
pub fn ModalState::close(Self) -> Unit
pub fn ModalState::get_is_open(Self) -> Bool
pub fn ModalState::new(initial_open? : Bool) -> Self
pub fn ModalState::open(Self) -> Unit
pub fn ModalState::toggle(Self) -> Unit

pub(all) struct Page {
  app : HeadlessApp
}
pub fn Page::content(Self) -> String
pub fn Page::keyboard(Self) -> Keyboard
pub fn Page::locator(Self, String) -> Locator
pub fn Page::new(HeadlessApp) -> Self

pub(all) enum ProgressStyle {
  Bar
  Dots
  Blocks
  Spinner
}

pub(all) struct Queue[T] {
  items : Array[T]
  is_processing : Ref[Bool]
}
pub fn[T] Queue::clear(Self[T]) -> Unit
pub fn[T] Queue::dequeue_all(Self[T]) -> Array[T]
pub fn[T] Queue::enqueue(Self[T], T) -> Unit
pub fn[T] Queue::finish_processing(Self[T]) -> Unit
pub fn[T] Queue::is_busy(Self[T]) -> Bool
pub fn[T] Queue::is_empty(Self[T]) -> Bool
pub fn[T] Queue::length(Self[T]) -> Int
pub fn[T] Queue::new() -> Self[T]
pub fn[T] Queue::peek_all(Self[T]) -> Array[T]
pub fn[T] Queue::start_processing(Self[T]) -> Unit

pub(all) struct RadioOption {
  id : String
  label : String
}
pub impl Eq for RadioOption

pub(all) enum RadioOrientation {
  Horizontal
  Vertical
}

pub(all) enum ScrollIndicator {
  None
  Up
  Down
  Both
}
pub impl Show for ScrollIndicator

pub(all) struct ScrollState {
  offset : @signals.Signal[Int]
  auto_scroll : @signals.Signal[Bool]
}
pub fn ScrollState::auto_scroll_to_bottom(Self, Int, Int) -> Unit
pub fn ScrollState::get_indicator(Self, Int, Int) -> ScrollIndicator
pub fn ScrollState::is_at_bottom(Self, Int, Int) -> Bool
pub fn ScrollState::new() -> Self
pub fn ScrollState::reset(Self) -> Unit
pub fn ScrollState::scroll_down(Self, Int, Int, Int) -> Bool
pub fn ScrollState::scroll_to_bottom(Self, Int, Int) -> Unit
pub fn ScrollState::scroll_up(Self, Int) -> Bool
pub fn ScrollState::with_values(Int, Bool) -> Self

pub(all) struct ScrollableView {
  lines : Ref[Array[StyledLine]]
  offset : @signals.Signal[Int]
  auto_scroll : @signals.Signal[Bool]
  width : Ref[Int]
  visible_height : Ref[Int]
}
pub fn ScrollableView::can_scroll_down(Self) -> Bool
pub fn ScrollableView::can_scroll_up(Self) -> Bool
pub fn ScrollableView::down(Self, Int) -> Bool
pub fn ScrollableView::follow_bottom(Self) -> Unit
pub fn ScrollableView::get_visible_height(Self) -> Int
pub fn ScrollableView::get_width(Self) -> Int
pub fn ScrollableView::max_offset(Self) -> Int
pub fn ScrollableView::new(Int, Int) -> Self
pub fn ScrollableView::resize(Self, Int, Int) -> Unit
pub fn ScrollableView::set_lines(Self, Array[StyledLine]) -> Unit
pub fn ScrollableView::to_bottom(Self) -> Unit
pub fn ScrollableView::total_lines(Self) -> Int
pub fn ScrollableView::up(Self, Int) -> Bool

pub(all) struct Selection {
  anchor : CursorPosition
  cursor : CursorPosition
}
pub fn Selection::is_empty(Self) -> Bool

pub(all) enum SelectionMode {
  Caret
  VisualChar
  VisualLine
  VisualBlock
}

pub(all) enum SplitDirection {
  Horizontal
  Vertical
}

pub(all) enum SplitSize {
  Fixed(Double)
  Percent(Double)
  Flex(Double)
}

pub(all) enum SplitterOrientation {
  Horizontal
  Vertical
}

pub(all) struct SplitterState {
  position : Int
  collapsed : Bool
  prev_position : Int
  focused : Bool
}
pub fn SplitterState::new(initial_position? : Int, collapsed? : Bool) -> Self

pub(all) struct StreamBuffer {
  app : Ref[@render.App]
  width : Ref[Int]
  height : Ref[Int]
}
pub fn StreamBuffer::clear(Self) -> Unit
pub fn StreamBuffer::new(Int, Int) -> Self
pub fn StreamBuffer::render(Self, @core.Component, row? : Int, col? : Int, preserve_cursor? : Bool) -> Unit
pub fn StreamBuffer::render_output(Self, @core.Component, row? : Int, col? : Int, preserve_cursor? : Bool) -> String
pub fn StreamBuffer::resize(Self, Int, Int) -> Unit
pub fn StreamBuffer::size(Self) -> (Int, Int)
pub fn StreamBuffer::sync(Self, @core.Component) -> Unit

pub(all) struct StreamingState {
  full_text : @signals.Signal[String]
  position : @signals.Signal[Int]
  ticker_id : Ref[Int]
}
pub fn StreamingState::append(Self, String) -> Unit
pub fn StreamingState::clear(Self) -> Unit
pub fn StreamingState::complete(Self) -> Unit
pub fn StreamingState::get_partial(Self) -> String
pub fn StreamingState::get_partial_with_cursor(Self, cursor? : String) -> String
pub fn StreamingState::get_progress(Self) -> (Int, Int)
pub fn StreamingState::get_progress_ratio(Self) -> Double
pub fn StreamingState::has_content(Self) -> Bool
pub fn StreamingState::is_streaming(Self) -> Bool
pub fn StreamingState::new() -> Self
pub fn StreamingState::start(Self, String, Int, () -> Unit, () -> Unit) -> Bool
pub fn StreamingState::start_realtime(Self) -> Bool
pub fn StreamingState::stop(Self) -> Unit
pub fn StreamingState::take(Self) -> String
pub fn StreamingState::take_partial(Self) -> String

pub(all) struct StyledLine {
  content : String
  fg : @core.Color
  bold : Bool
}
pub fn StyledLine::new(String, fg? : @core.Color, bold? : Bool) -> Self
pub fn StyledLine::plain(String) -> Self

pub(all) enum SwitchState {
  Off
  On
  Focused
  Disabled
}

pub(all) struct TabItem {
  label : String
  id : String
}
pub impl Eq for TabItem

pub(all) enum TabOrientation {
  Horizontal
  Vertical
}

pub(all) enum TextAlign {
  Left
  Right
  Center
}

pub(all) struct TextBuffer {
  lines : Array[String]
  cursor : CursorPosition
  selection : Selection
  mode : SelectionMode
  modified : Bool
}
pub fn TextBuffer::current_line(Self) -> String
pub fn TextBuffer::cursor(Self) -> CursorPosition
pub fn TextBuffer::delete_backwards(Self) -> Self
pub fn TextBuffer::delete_forwards(Self) -> Self
pub fn TextBuffer::delete_line(Self) -> Self
pub fn TextBuffer::from_file(String) -> Self
pub fn TextBuffer::from_string(String) -> Self
pub fn TextBuffer::insert_char(Self, Char) -> Self
pub fn TextBuffer::insert_newline(Self) -> Self
pub fn TextBuffer::insert_string(Self, String) -> Self
pub fn TextBuffer::line_count(Self) -> Int
pub fn TextBuffer::move_to(Self, Int, Int) -> Self
pub fn TextBuffer::new() -> Self
pub fn TextBuffer::to_string(Self) -> String

pub(all) enum TextareaState {
  Idle
  Focused
  Editing
  Disabled
}

pub(all) struct Theme {
  mode : ThemeMode
  primary : @core.Color
  focus : @core.Color
  fg : @core.Color
  muted : @core.Color
  disabled : @core.Color
  bg : @core.Color
  surface : @core.Color
  border : @core.Color
  success : @core.Color
  error : @core.Color
}
pub fn Theme::dark(primary? : @core.Color) -> Self
pub fn Theme::default() -> Self
pub fn Theme::focused_color(Self) -> @core.Color
pub fn Theme::interactive_color(Self) -> @core.Color
pub fn Theme::light(primary? : @core.Color) -> Self
pub fn Theme::selected_color(Self) -> @core.Color

pub(all) enum ThemeMode {
  Light
  Dark
}

pub(all) struct UndoStack {
  history : Array[String]
  max_size : Int
}
pub fn UndoStack::new() -> Self
pub fn UndoStack::push(Self, String) -> Self
pub fn UndoStack::redo_count(Self) -> Int
pub fn UndoStack::undo_count(Self) -> Int

// Type aliases

// Traits

