// Generated using `moon info`, DON'T EDIT IT
package "mizchi/crater/scheduler"

import {
  "mizchi/crater/css/cascade",
  "mizchi/crater/css/selector",
  "mizchi/crater/html",
  "mizchi/crater/layout/node",
  "mizchi/crater/layout/tree",
  "mizchi/crater/types",
  "moonbitlang/core/hashset",
}

// Values
pub fn compute_element_style(StyleManager, @html.Element) -> @cascade.CascadedValues

pub fn discover_resources(@html.Element) -> ResourceDiscoveryResult

pub fn has_alt(Int) -> Bool

pub fn has_ctrl(Int) -> Bool

pub fn has_meta(Int) -> Bool

pub fn has_shift(Int) -> Bool

pub fn html_element_to_selector(@html.Element) -> @selector.Element

pub fn parse_and_schedule(Scheduler, String, base_url? : String) -> ParseCompleteResult

pub fn reset_request_id_counter() -> Unit

pub fn reset_task_id_counter() -> Unit

// Errors

// Types and methods
type BlockedSources

pub(all) struct CSSParseResult {
  stylesheet : @cascade.Stylesheet
  recompute_task : TaskId?
  rule_count : Int
}

pub(all) struct DiscoveredResource {
  url : String
  resource_type : ResourceType
  blocking : Bool
  is_defer : Bool
  is_async : Bool
}

pub struct DocumentParser {
  scheduler : Scheduler
  mut parsed_root : @html.Element?
  mut discovered : ResourceDiscoveryResult?
  base_url : String
}
pub fn DocumentParser::get_discovered_resources(Self) -> ResourceDiscoveryResult?
pub fn DocumentParser::get_root(Self) -> @html.Element?
pub fn DocumentParser::new(Scheduler, base_url? : String) -> Self
pub fn DocumentParser::on_parse_complete(Self, String) -> ParseCompleteResult
pub fn DocumentParser::start_parse(Self, String) -> TaskId

pub struct DocumentRenderCoordinator {
  scheduler : Scheduler
  style_coordinator : DocumentStyleCoordinator
  layout_manager : LayoutManager
  mut ready_for_render : Bool
}
pub fn DocumentRenderCoordinator::get_layout_manager(Self) -> LayoutManager
pub fn DocumentRenderCoordinator::get_style_coordinator(Self) -> DocumentStyleCoordinator
pub fn DocumentRenderCoordinator::is_ready_for_render(Self) -> Bool
pub fn DocumentRenderCoordinator::new(Scheduler) -> Self
pub fn DocumentRenderCoordinator::on_stylesheet_fetched(Self, String) -> CSSParseResult
pub fn DocumentRenderCoordinator::process_html(Self, ParseCompleteResult, ResourceDiscoveryResult, Double, Double) -> RenderPipelineResult

pub struct DocumentStyleCoordinator {
  scheduler : Scheduler
  style_manager : StyleManager
  mut parsed_stylesheets : Int
  mut expected_stylesheets : Int
  mut ready_for_style : Bool
}
pub fn DocumentStyleCoordinator::get_style_manager(Self) -> StyleManager
pub fn DocumentStyleCoordinator::is_ready_for_style(Self) -> Bool
pub fn DocumentStyleCoordinator::new(Scheduler) -> Self
pub fn DocumentStyleCoordinator::on_stylesheet_fetched(Self, String) -> CSSParseResult
pub fn DocumentStyleCoordinator::register_stylesheets(Self, ParseCompleteResult, ResourceDiscoveryResult) -> Unit
pub fn DocumentStyleCoordinator::schedule_style_computation(Self, Array[String]) -> TaskId

pub(all) enum FetchResult {
  Success(response~ : NetworkResponse)
  Redirect(location~ : String, status~ : Int)
  Failure(error~ : String)
}
pub impl Show for FetchResult

pub(all) enum HttpMethod {
  GET
  POST
  PUT
  DELETE
  HEAD
  OPTIONS
  PATCH
}
pub fn HttpMethod::from_string(String) -> Self
pub fn HttpMethod::to_string(Self) -> String
pub impl Eq for HttpMethod
pub impl Show for HttpMethod

pub(all) struct ImageRegistration {
  resource_id : @tree.ResourceId
  decode_task : TaskId
  registered : Bool
}

pub(all) struct InlineScript {
  source : String
  blocking : Bool
}

pub(all) enum InputEvent {
  Mouse(MouseEvent)
  Keyboard(KeyboardEvent)
  Text(String)
}
pub impl Show for InputEvent

pub struct InputManager {
  pending_events : Array[InputEvent]
  mut enabled : Bool
}
pub fn InputManager::disable(Self) -> Unit
pub fn InputManager::enable(Self) -> Unit
pub fn InputManager::new() -> Self
pub fn InputManager::queue_event(Self, InputEvent) -> Unit
pub fn InputManager::take_events(Self) -> Array[InputEvent]

pub(all) enum KeyEventType {
  KeyDown
  KeyUp
  RawKeyDown
  Char
}
pub impl Eq for KeyEventType
pub impl Show for KeyEventType

pub(all) struct KeyboardEvent {
  event_type : KeyEventType
  key : String
  code : String
  modifiers : Int
  text : String?
  timestamp : Double
}
pub fn KeyboardEvent::new(KeyEventType, String) -> Self
pub fn KeyboardEvent::with_code(Self, String) -> Self
pub fn KeyboardEvent::with_modifiers(Self, Int) -> Self
pub fn KeyboardEvent::with_text(Self, String) -> Self
pub impl Show for KeyboardEvent

pub(all) struct LayoutComputeResult {
  layout : @types.Layout
  was_incremental : Bool
  pending_images : Int
}

pub struct LayoutManager {
  scheduler : Scheduler
  mut layout_tree : @tree.LayoutTree?
  mut last_layout : @types.Layout?
  mut full_layout_count : Int
  mut incremental_layout_count : Int
  image_tasks : Map[Int, TaskId]
}
pub fn LayoutManager::batch_update_styles(Self, Array[(String, @cascade.CascadedValues)]) -> Int
pub fn LayoutManager::build_tree(Self, @node.Node, Double, Double) -> Unit
pub fn LayoutManager::build_tree_from_html(Self, @html.Document, Double, Double) -> Unit
pub fn LayoutManager::execute_layout(Self, incremental? : Bool) -> LayoutComputeResult
pub fn LayoutManager::get_pending_images(Self) -> Array[@tree.ResourceId]
pub fn LayoutManager::get_stats(Self) -> LayoutStats
pub fn LayoutManager::get_tree(Self) -> @tree.LayoutTree?
pub fn LayoutManager::mark_node_dirty(Self, Int) -> Unit
pub fn LayoutManager::new(Scheduler) -> Self
pub fn LayoutManager::on_image_decoded(Self, @tree.ResourceId, Double, Double) -> TaskId?
pub fn LayoutManager::on_image_failed(Self, @tree.ResourceId) -> TaskId?
pub fn LayoutManager::register_and_decode_image(Self, Int, placeholder_width? : Double, placeholder_height? : Double) -> ImageRegistration
pub fn LayoutManager::schedule_image_decode(Self, @tree.ResourceId) -> TaskId
pub fn LayoutManager::schedule_layout(Self) -> TaskId
pub fn LayoutManager::schedule_layout_after(Self, Array[TaskId]) -> TaskId
pub fn LayoutManager::schedule_layout_urgent(Self) -> TaskId
pub fn LayoutManager::schedule_resize(Self, Double, Double) -> ResizeResult
pub fn LayoutManager::set_tree(Self, @tree.LayoutTree) -> Unit
pub fn LayoutManager::update_node_style(Self, String, @cascade.CascadedValues) -> Bool

pub(all) struct LayoutStats {
  full_layout_count : Int
  incremental_layout_count : Int
  pending_images : Int
}

pub(all) enum MouseButton {
  None
  Left
  Middle
  Right
  Back
  Forward
}
pub impl Eq for MouseButton
pub impl Show for MouseButton

pub(all) struct MouseEvent {
  event_type : MouseEventType
  x : Double
  y : Double
  button : MouseButton
  buttons : Int
  click_count : Int
  modifiers : Int
  timestamp : Double
}
pub fn MouseEvent::new(MouseEventType, Double, Double) -> Self
pub fn MouseEvent::with_button(Self, MouseButton) -> Self
pub fn MouseEvent::with_modifiers(Self, Int) -> Self
pub impl Show for MouseEvent

pub(all) enum MouseEventType {
  MousePressed
  MouseReleased
  MouseMoved
  MouseWheel
}
pub impl Eq for MouseEventType
pub impl Show for MouseEventType

pub(all) enum NetworkEvent {
  RequestWillBeSent(NetworkRequest)
  ResponseReceived(NetworkResponse)
  LoadingFinished(request_id~ : RequestId, encoded_data_length~ : Int)
  LoadingFailed(request_id~ : RequestId, error~ : String)
}
pub fn NetworkEvent::request_id(Self) -> RequestId
pub impl Show for NetworkEvent

pub struct NetworkManager {
  pending_requests : Map[Int, NetworkRequest]
  mut pending_events : Array[NetworkEvent]
  mut enabled : Bool
}
pub fn NetworkManager::disable(Self) -> Unit
pub fn NetworkManager::drain_events(Self) -> Array[NetworkEvent]
pub fn NetworkManager::enable(Self) -> Unit
pub fn NetworkManager::fail_loading(Self, RequestId, String) -> Unit
pub fn NetworkManager::finish_loading(Self, RequestId, Int) -> Unit
pub fn NetworkManager::has_pending_events(Self) -> Bool
pub fn NetworkManager::new() -> Self
pub fn NetworkManager::pending_count(Self) -> Int
pub fn NetworkManager::receive_response(Self, NetworkResponse) -> Unit
pub fn NetworkManager::start_request(Self, NetworkRequest) -> Unit

pub(all) struct NetworkRequest {
  id : RequestId
  url : String
  http_method : HttpMethod
  resource_type : ResourceType
  headers : Map[String, String]
  document_url : String
  frame_id : String
  loader_id : String
  timestamp : Double
}
pub fn NetworkRequest::new(String, ResourceType, document_url? : String, frame_id? : String, http_method? : HttpMethod) -> Self
pub fn NetworkRequest::with_headers(Self, Map[String, String]) -> Self
pub fn NetworkRequest::with_loader_id(Self, String) -> Self
pub fn NetworkRequest::with_timestamp(Self, Double) -> Self
pub impl Show for NetworkRequest

pub(all) struct NetworkResponse {
  request_id : RequestId
  url : String
  status : Int
  status_text : String
  mime_type : String
  headers : Map[String, String]
  body : String?
  content_length : Int
  timestamp : Double
  loader_id : String
}
pub fn NetworkResponse::new(RequestId, String, Int) -> Self
pub fn NetworkResponse::with_body(Self, String) -> Self
pub fn NetworkResponse::with_headers(Self, Map[String, String]) -> Self
pub fn NetworkResponse::with_loader_id(Self, String) -> Self
pub fn NetworkResponse::with_mime_type(Self, String) -> Self
pub fn NetworkResponse::with_timestamp(Self, Double) -> Self
pub impl Show for NetworkResponse

pub(all) struct ParseCompleteResult {
  root : @html.Element
  fetch_tasks : Array[TaskId]
  style_tasks : Array[TaskId]
  script_tasks : Array[TaskId]
  blocking_tasks : Array[TaskId]
  resource_count : Int
  inline_style_count : Int
  inline_script_count : Int
}

pub(all) struct RenderPipelineResult {
  style_ready : Bool
  layout_task : TaskId?
  image_decode_tasks : Array[TaskId]
}

pub(all) struct RequestId(Int)
#deprecated
pub fn RequestId::inner(Self) -> Int
pub fn RequestId::next() -> Self
pub impl Eq for RequestId
pub impl Hash for RequestId
pub impl Show for RequestId

pub(all) struct ResizeResult {
  resized : Bool
  layout_task : TaskId?
}

pub(all) struct ResourceDiscoveryResult {
  resources : Array[DiscoveredResource]
  inline_styles : Array[String]
  inline_scripts : Array[InlineScript]
}
pub fn ResourceDiscoveryResult::filter_by_type(Self, ResourceType) -> Array[DiscoveredResource]
pub fn ResourceDiscoveryResult::get_blocking(Self) -> Array[DiscoveredResource]
pub fn ResourceDiscoveryResult::get_urls(Self) -> Array[String]
pub fn ResourceDiscoveryResult::new() -> Self

pub(all) enum ResourceType {
  Document
  Stylesheet
  Script
  Image
  Font
  Other
}
pub impl Eq for ResourceType
pub impl Show for ResourceType

pub struct Scheduler {
  tasks : Map[Int, Task]
  ready_queue : TaskQueue
  source_queues : SourceQueueManager
  blocked : BlockedSources
  completed_ids : @hashset.HashSet[Int]
}
pub fn Scheduler::apply_blocks(Self, Task) -> Unit
pub fn Scheduler::cancel(Self, TaskId) -> Unit
pub fn Scheduler::cleanup(Self) -> Int
pub fn Scheduler::complete(Self, TaskId, TaskResult) -> Array[TaskId]
pub fn Scheduler::enqueue(Self, TaskAction, TaskConstraint) -> TaskId
pub fn Scheduler::enqueue_after(Self, TaskAction, TaskConstraint, Array[TaskId]) -> TaskId
pub fn Scheduler::enqueue_with_priority(Self, TaskAction, TaskConstraint, Int) -> TaskId
pub fn Scheduler::fail(Self, TaskId, String) -> Unit
pub fn Scheduler::find_task(Self, TaskId) -> Task?
pub fn Scheduler::is_idle(Self) -> Bool
pub fn Scheduler::is_source_blocked(Self, TaskSource) -> Bool
pub fn Scheduler::new() -> Self
pub fn Scheduler::pending_count(Self) -> Int
pub fn Scheduler::poll_main_thread(Self) -> Task?
pub fn Scheduler::poll_parallel(Self) -> Array[Task]
pub fn Scheduler::poll_ready(Self) -> Array[Task]
pub fn Scheduler::ready_count(Self) -> Int
pub fn Scheduler::resolve_dependencies(Self) -> Int
pub fn Scheduler::running_count(Self) -> Int
pub fn Scheduler::task_count(Self) -> Int

pub struct SourceQueueManager {
  queues : Map[TaskSource, TaskQueue]
}
pub fn SourceQueueManager::cleanup(Self) -> Int
pub fn SourceQueueManager::find(Self, TaskId) -> Task?
pub fn SourceQueueManager::get_all_ready(Self) -> Array[Task]
pub fn SourceQueueManager::get_queue(Self, TaskSource) -> TaskQueue
pub fn SourceQueueManager::get_ready_by_source(Self, TaskSource) -> Array[Task]
pub fn SourceQueueManager::new() -> Self
pub fn SourceQueueManager::push(Self, Task) -> Unit
pub fn SourceQueueManager::remove(Self, TaskId) -> Task?
pub fn SourceQueueManager::total_count(Self) -> Int

pub struct StyleManager {
  scheduler : Scheduler
  stylesheets : Array[@cascade.Stylesheet]
  inline_styles : Map[String, Array[@cascade.Declaration]]
  computed_styles : Map[String, @cascade.CascadedValues]
  mut source_order : Int
}
pub fn StyleManager::add_inline_style(Self, String, String) -> Unit
pub fn StyleManager::add_stylesheet(Self, @cascade.Stylesheet) -> Unit
pub fn StyleManager::add_stylesheet_source(Self, String) -> @cascade.Stylesheet
pub fn StyleManager::compute_style(Self, @selector.Element) -> @cascade.CascadedValues
pub fn StyleManager::invalidate_all_styles(Self) -> Unit
pub fn StyleManager::invalidate_style(Self, String) -> Unit
pub fn StyleManager::new(Scheduler) -> Self
pub fn StyleManager::on_css_parsed(Self, String) -> CSSParseResult
pub fn StyleManager::schedule_compute_style(Self, Array[String]) -> TaskId
pub fn StyleManager::schedule_parse_css(Self, String) -> TaskId

pub(all) struct Task {
  id : TaskId
  source : TaskSource
  constraint : TaskConstraint
  dependencies : Array[TaskId]
  action : TaskAction
  mut state : TaskState
  priority : Int
}
pub fn Task::is_completed(Self) -> Bool
pub fn Task::is_parallel(Self) -> Bool
pub fn Task::is_ready(Self) -> Bool
pub fn Task::is_terminal(Self) -> Bool
pub fn Task::mark_cancelled(Self) -> Unit
pub fn Task::mark_completed(Self) -> Unit
pub fn Task::mark_failed(Self, String) -> Unit
pub fn Task::mark_running(Self) -> Unit
pub fn Task::new(TaskAction, TaskConstraint, dependencies? : Array[TaskId], priority? : Int) -> Self

pub(all) enum TaskAction {
  ParseHTMLChunk(html~ : String)
  ParseCSS(source~ : String)
  ComputeStyle(node_ids~ : Array[String])
  ComputeLayout
  FetchResource(url~ : String, resource_type~ : ResourceType)
  DecodeImage(resource_id~ : Int)
  ExecuteScript(source~ : String)
}
pub fn TaskAction::is_internal(Self) -> Bool
pub fn TaskAction::source(Self) -> TaskSource
pub impl Show for TaskAction

pub(all) enum TaskConstraint {
  MainThreadOnly
  Parallel
  Blocking(Array[TaskSource])
}
pub fn TaskConstraint::blocks(Self, TaskSource) -> Bool
pub fn TaskConstraint::is_parallel(Self) -> Bool
pub impl Show for TaskConstraint

pub(all) struct TaskId(Int)
#deprecated
pub fn TaskId::inner(Self) -> Int
pub impl Eq for TaskId
pub impl Hash for TaskId
pub impl Show for TaskId

pub struct TaskQueue {
  tasks : Array[Task]
}
pub fn TaskQueue::cleanup(Self) -> Int
pub fn TaskQueue::find(Self, TaskId) -> Task?
pub fn TaskQueue::get_main_thread_ready(Self) -> Array[Task]
pub fn TaskQueue::get_parallel_ready(Self) -> Array[Task]
pub fn TaskQueue::get_ready(Self) -> Array[Task]
pub fn TaskQueue::is_empty(Self) -> Bool
pub fn TaskQueue::iter(Self) -> Iter[Task]
pub fn TaskQueue::length(Self) -> Int
pub fn TaskQueue::new() -> Self
pub fn TaskQueue::push(Self, Task) -> Unit
pub fn TaskQueue::remove(Self, TaskId) -> Task?
pub fn TaskQueue::sort_by_priority(Self) -> Unit

pub(all) enum TaskResult {
  Success(new_tasks~ : Array[TaskAction])
  Failure(error~ : String)
  Cancelled
}
pub impl Show for TaskResult

pub(all) enum TaskSource {
  DOM
  Styling
  Layout
  Networking
  Scripting
  ImageDecode
}
pub impl Eq for TaskSource
pub impl Hash for TaskSource
pub impl Show for TaskSource

pub(all) enum TaskState {
  Pending
  Ready
  Running
  Completed
  Cancelled
  Failed(String)
}
pub fn TaskState::is_runnable(Self) -> Bool
pub fn TaskState::is_terminal(Self) -> Bool
pub impl Show for TaskState

// Type aliases

// Traits

