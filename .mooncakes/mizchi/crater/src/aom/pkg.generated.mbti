// Generated using `moon info`, DON'T EDIT IT
package "mizchi/crater/aom"

import {
  "mizchi/crater/html",
  "mizchi/crater/layout/tree",
  "mizchi/crater/types",
}

// Values
pub fn attach_bounds(AccessibilityTree, Map[String, Bounds]) -> AccessibilityTree

pub fn build_accessibility_tree(@html.Document) -> AccessibilityTree

pub fn build_accessibility_tree_from_element(@html.Element) -> AccessibilityTree

pub fn build_accessibility_tree_lightweight(@html.Document) -> AccessibilityTree

pub fn build_accessibility_tree_with_layout(@html.Document, @tree.LayoutTree) -> AccessibilityTree

pub fn build_accessibility_tree_with_node_layout(@html.Document, @types.Layout) -> AccessibilityTree

pub fn compute_accessible_description(@html.Element, (String) -> @html.Element?) -> String?

pub fn compute_accessible_description_with_label(@html.Element, (String) -> @html.Element?, (String) -> @html.Element?) -> String?

pub fn compute_accessible_name(@html.Element, (String) -> @html.Element?) -> String?

pub fn compute_accessible_name_full(@html.Element, (String) -> @html.Element?, (String) -> @html.Element?, @html.Element?) -> String?

pub fn compute_accessible_name_with_label(@html.Element, (String) -> @html.Element?, (String) -> @html.Element?) -> String?

pub fn compute_role(@html.Element, RoleMappingContext) -> Role

pub fn compute_tab_order(AccessibilityTree) -> Array[FocusableItem]

pub fn extract_bounds_from_layout(@tree.LayoutTree) -> Map[String, Bounds]

pub fn extract_bounds_from_node_layout(@types.Layout) -> Map[String, Bounds]

pub fn find_headings(AccessibilityTree) -> Array[AccessibilityNode]

pub fn find_interactive(AccessibilityTree) -> Array[AccessibilityNode]

pub fn find_landmarks(AccessibilityTree) -> Array[AccessibilityNode]

pub fn get_heading_level(@html.Element) -> Int?

pub fn get_tab_order_ids(AccessibilityTree) -> Array[String]

pub fn get_tab_order_info(AccessibilityTree) -> Array[(String, String?, Role)]

pub fn is_sectioning_content(String) -> Bool

pub fn role_is_inherently_focusable(Role) -> Bool

pub fn role_is_landmark(Role) -> Bool

pub fn role_supports_name_from_content(Role) -> Bool

// Errors

// Types and methods
pub(all) struct AccessibilityNode {
  id : String
  role : Role
  name : String?
  description : String?
  level : Int?
  states : Array[State]
  properties : Map[String, String]
  bounds : Bounds?
  children : Array[AccessibilityNode]
  focusable : Bool
  tabindex : Int?
  source_id : String?
  href : String?
  tag_name : String?
  selector : String?
  visible : Bool
  ref_id : String?
  input_type : String?
  placeholder : String?
  input_value : String?
  required : Bool
  text : String?
  options : Array[SelectOption]
  labelled_by : String?
}
pub fn AccessibilityNode::add_child(Self, Self) -> Self
pub fn AccessibilityNode::add_state(Self, State) -> Self
pub fn AccessibilityNode::new(String, Role) -> Self
pub fn AccessibilityNode::set_focusable(Self, Bool) -> Self
pub fn AccessibilityNode::to_aria_json(Self) -> String
pub fn AccessibilityNode::to_aria_snapshot(Self) -> String
pub fn AccessibilityNode::with_bounds(Self, Bounds) -> Self
pub fn AccessibilityNode::with_level(Self, Int) -> Self
pub fn AccessibilityNode::with_name(Self, String) -> Self
pub fn AccessibilityNode::with_tabindex(Self, Int) -> Self

pub(all) struct AccessibilityTree {
  root : AccessibilityNode
  node_map : Map[String, AccessibilityNode]
}
pub fn AccessibilityTree::find_by_id(Self, String) -> AccessibilityNode?
pub fn AccessibilityTree::find_by_role(Self, Role) -> Array[AccessibilityNode]
pub fn AccessibilityTree::find_by_source_id(Self, String) -> AccessibilityNode?
pub fn AccessibilityTree::find_focusable(Self) -> Array[AccessibilityNode]
pub fn AccessibilityTree::new(AccessibilityNode) -> Self
pub fn AccessibilityTree::to_aria_json(Self) -> String
pub fn AccessibilityTree::to_aria_snapshot(Self) -> String

pub(all) struct Bounds {
  x : Double
  y : Double
  width : Double
  height : Double
}
pub fn Bounds::default() -> Self
pub fn Bounds::new(Double, Double, Double, Double) -> Self

pub(all) struct FocusManager {
  tree : AccessibilityTree
  tab_order : Array[FocusableItem]
  mut current_index : Int
}
pub fn FocusManager::blur(Self) -> Unit
pub fn FocusManager::current(Self) -> AccessibilityNode?
pub fn FocusManager::current_id(Self) -> String?
pub fn FocusManager::focus_by_id(Self, String) -> Bool
pub fn FocusManager::focus_by_source_id(Self, String) -> Bool
pub fn FocusManager::focus_first(Self) -> AccessibilityNode?
pub fn FocusManager::focus_last(Self) -> AccessibilityNode?
pub fn FocusManager::focus_next(Self) -> AccessibilityNode?
pub fn FocusManager::focus_prev(Self) -> AccessibilityNode?
pub fn FocusManager::focusable_count(Self) -> Int
pub fn FocusManager::get_tab_order(Self) -> Array[FocusableItem]
pub fn FocusManager::has_focus(Self) -> Bool
pub fn FocusManager::new(AccessibilityTree) -> Self

pub(all) struct FocusableItem {
  node : AccessibilityNode
  document_order : Int
  effective_tabindex : Int
}

pub(all) enum Role {
  Article
  Blockquote
  Caption
  Cell
  Code
  ColumnHeader
  Definition
  Deletion
  Directory
  Document
  Emphasis
  Feed
  Figure
  Generic
  Group
  Heading
  Img
  Insertion
  List
  ListItem
  Mark
  Math
  Meter
  None
  Note
  Paragraph
  Presentation
  Row
  RowGroup
  RowHeader
  Separator
  Strong
  Subscript
  Superscript
  Table
  Term
  Time
  Toolbar
  Tooltip
  Button
  Checkbox
  Combobox
  GridCell
  Link
  Listbox
  Menu
  MenuBar
  MenuItem
  MenuItemCheckbox
  MenuItemRadio
  Option
  Progressbar
  Radio
  RadioGroup
  Scrollbar
  SearchBox
  Slider
  SpinButton
  Switch
  Tab
  TabList
  TabPanel
  Textbox
  Tree
  TreeGrid
  TreeItem
  Application
  Banner
  Complementary
  ContentInfo
  Form
  Main
  Navigation
  Region
  Search
  Alert
  AlertDialog
  Dialog
  Log
  Marquee
  Status
  Timer
  Window
  HtmlAudio
  HtmlVideo
  HtmlCanvas
  HtmlLabel
  HtmlSummary
}
pub fn Role::from_string(String) -> Self?
pub fn Role::to_string(Self) -> String
pub impl Eq for Role
pub impl Show for Role

pub(all) struct RoleMappingContext {
  parent_tag : String?
  has_accessible_name : Bool
  in_sectioning_content : Bool
}
pub fn RoleMappingContext::default() -> Self

pub(all) struct SelectOption {
  value : String
  label : String
  selected : Bool
}

pub(all) enum State {
  Busy
  Checked
  Disabled
  Expanded
  Grabbed
  Hidden
  Invalid
  Pressed
  Selected
  CheckedMixed
  PressedMixed
}
pub fn State::to_string(Self) -> String
pub impl Eq for State
pub impl Show for State

// Type aliases

// Traits

